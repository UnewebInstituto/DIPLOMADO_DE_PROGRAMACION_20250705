¬°Claro\! La secuencia de comandos para activar un entorno virtual de Python depende de c√≥mo se haya creado, pero la forma m√°s com√∫n, y la que funciona bien en Git Bash, es ejecutar el *script* de activaci√≥n ubicado dentro del directorio del entorno virtual.

Aqu√≠ tienes los pasos, asumiendo que el entorno virtual se llama `venv`:

### üêç Activaci√≥n del Entorno Virtual en Git Bash

1.  **Navega** hasta el directorio ra√≠z de tu proyecto (donde se encuentra la carpeta de tu entorno virtual, ej. `venv`).

2.  **Ejecuta el script de activaci√≥n** usando el siguiente comando:

    ```bash
    source venv/Scripts/activate
    ```

      * **`source`**: Este comando es esencial en sistemas tipo Unix (como el entorno de Git Bash) para ejecutar el *script* en el *shell* actual y modificar la configuraci√≥n de la sesi√≥n (como la variable de entorno `PATH`).
      * **`venv/Scripts/activate`**: Esta es la ruta al *script* de activaci√≥n dentro de la carpeta de tu entorno virtual (`venv`). En Windows, cuando se usa Python, el *script* ejecutable est√° en el subdirectorio `Scripts`.

### ‚ú® Verificaci√≥n

Una vez que el entorno virtual se ha activado con √©xito, ver√°s el nombre de tu entorno (generalmente entre par√©ntesis) prefijando tu *prompt* de Git Bash.

**Ejemplo:**

```bash
(venv) user@host MINGW64 /c/ruta/a/mi/proyecto
```

Ahora, cualquier comando de Python que ejecutes (como `pip install`, `python script.py`) se referir√° a la versi√≥n de Python y los paquetes instalados **dentro** de ese entorno virtual, y no a la instalaci√≥n global de tu sistema.

### üõë Desactivaci√≥n (Opcional)

Cuando termines de trabajar en el proyecto, puedes desactivar el entorno virtual simplemente ejecutando:

```bash
deactivate
```

-----

¬øTe gustar√≠a que te recuerde c√≥mo **crear** un entorno virtual si a√∫n no lo has hecho?


¬°Excelente pregunta\! En Python, la declaraci√≥n de un m√©todo constructor es fundamental para **inicializar** los objetos (instancias) de una clase.

Este m√©todo especial se llama **`__init__`**.

A continuaci√≥n, describo su declaraci√≥n, prop√≥sito y c√≥mo funciona:

-----

## üèóÔ∏è La Declaraci√≥n del Constructor (`__init__`)

El constructor en Python se declara como un m√©todo regular dentro de la definici√≥n de una clase, pero siempre debe llevar el nombre `__init__` (doble guion bajo antes y despu√©s).

### 1\. Sintaxis B√°sica

```python
class NombreClase:
    def __init__(self, parametro1, parametro2, ...):
        # Cuerpo del constructor:
        # Aqu√≠ se inicializan los atributos del objeto.
        self.atributo1 = parametro1
        self.atributo2 = parametro2
        # ...
```

### 2\. El Par√°metro `self` (Obligatorio)

El primer par√°metro de `__init__` **siempre** debe ser `self` (por convenci√≥n, aunque puedes usar otro nombre).

  * **Prop√≥sito de `self`:** Cuando se crea una nueva instancia de la clase (ej: `mi_objeto = NombreClase(...)`), Python llama autom√°ticamente a `__init__` y le pasa la **instancia reci√©n creada** como argumento para el par√°metro `self`. Es la referencia al objeto mismo.
  * **Inicializaci√≥n de Atributos:** Usamos `self` dentro del constructor para crear y asignar valores a los atributos espec√≠ficos de ese objeto: `self.nombre_atributo = valor`.

### 3\. Otros Par√°metros

Aparte de `self`, puedes incluir cualquier otro par√°metro que necesites para inicializar los atributos del objeto. Estos son los valores que el usuario de la clase proporcionar√° al momento de crear la instancia.

**Ejemplo:**

```python
class Perro:
    # Declaraci√≥n del constructor
    def __init__(self, nombre, edad):
        # 1. 'self' es la instancia de Perro que se est√° creando.
        # 2. Inicializamos los atributos 'nombre' y 'edad'
        #    de esta instancia usando los valores pasados.
        self.nombre = nombre
        self.edad = edad
        self.especie = "Canis familiaris" # Atributo con valor fijo
        
# Uso (Creaci√≥n del Objeto):
# Al llamar a Perro("Fido", 3), Python llama a __init__
# donde self es el nuevo objeto, nombre es "Fido" y edad es 3.
mi_perro = Perro("Fido", 3)

print(mi_perro.nombre) # Salida: Fido
print(mi_perro.edad)   # Salida: 3
```

-----

## üìå Puntos Clave sobre `__init__`

| Caracter√≠stica | Descripci√≥n |
| :--- | :--- |
| **Nombre** | **`__init__`** (siempre con doble guion bajo). |
| **Cu√°ndo se Llama** | Autom√°ticamente cuando se crea una nueva instancia de la clase (ej: `objeto = Clase()`). |
| **Prop√≥sito** | Asignar valores iniciales a los atributos del objeto. **No** es el m√©todo que crea el objeto (eso lo hace `__new__`), sino el que lo inicializa. |
| **Retorno** | No puede tener una declaraci√≥n de retorno (`return`); siempre debe retornar `None` impl√≠citamente. |

-----

¬øTe gustar√≠a ver un ejemplo m√°s avanzado que use argumentos predeterminados (`default arguments`) en el constructor?

Las declaraciones en Python que usan doble guion bajo al inicio y al final (por ejemplo, `__init__`, `__str__`, `__add__`) se conocen como **m√©todos m√°gicos** o **m√©todos dunder** (del ingl√©s "Double Under").

Estos m√©todos son fundamentales porque permiten que las clases de Python interact√∫en con las caracter√≠sticas del lenguaje (como operadores, funciones integradas, o sintaxis) de una manera definida.

### üßô‚Äç‚ôÇÔ∏è M√©todos M√°gicos o Dunder

El t√©rmino m√°s formal es **M√©todos M√°gicos** (Magic Methods), pero "dunder" es el t√©rmino de jerga m√°s utilizado en la comunidad de Python.

#### üìù Lista de M√©todos Dunder Comunes

Aqu√≠ tienes una lista de los m√©todos dunder m√°s importantes y las operaciones que permiten en una clase:

| Categor√≠a | M√©todo Dunder | Prop√≥sito y Uso |
| :--- | :--- | :--- |
| **Inicializaci√≥n y Creaci√≥n** | `__init__(self, ...)` | **Constructor**. Inicializa una instancia despu√©s de que ha sido creada. |
| | `__new__(cls, ...)` | Se llama para **crear** la instancia. (Menos com√∫n de sobrescribir). |
| | `__del__(self)` | Destructor. Se llama cuando el objeto es recolectado por el *garbage collector*. |
| **Representaci√≥n** | `__str__(self)` | Define la representaci√≥n en **cadena legible** para los humanos (usado por `print()` o `str()`). |
| | `__repr__(self)` | Define la representaci√≥n **formal** de la cadena (√∫til para depuraci√≥n). |
| **Comparaci√≥n de Objetos** | `__eq__(self, other)` | Define el comportamiento del operador de igualdad (`==`). |
| | `__lt__(self, other)` | Define el comportamiento del operador "menor que" (`<`). |
| | `__gt__(self, other)` | Define el comportamiento del operador "mayor que" (`>`). |
| **Operaciones Aritm√©ticas** | `__add__(self, other)` | Define el comportamiento del operador de suma (`+`). |
| | `__sub__(self, other)` | Define el comportamiento del operador de resta (`-`). |
| | `__mul__(self, other)` | Define el comportamiento del operador de multiplicaci√≥n (`*`). |
| **Contenedores y Colecciones**| `__len__(self)` | Define el comportamiento de la funci√≥n `len()`. |
| | `__getitem__(self, key)` | Permite acceder a elementos usando corchetes (ej: `objeto[clave]`). |
| | `__setitem__(self, key, value)`| Permite asignar valores usando corchetes (ej: `objeto[clave] = valor`). |
| **Context Managers** | `__enter__(self)` | Se llama al entrar en el bloque `with`. |
| | `__exit__(self, exc_type, ...)` | Se llama al salir del bloque `with`. |



Estos m√©todos son el coraz√≥n de la **programaci√≥n orientada a objetos (POO)** en Python, ya que permiten que tus objetos personalizados se comporten como tipos de datos nativos del lenguaje.

¬øTe gustar√≠a que te muestre un ejemplo de c√≥mo usar uno de estos m√©todos, como `__str__` o `__add__`?

¬°Es una excelente pregunta que toca un tema crucial en la Programaci√≥n Orientada a Objetos (POO) en Python\!

La respuesta directa es que **Python no tiene una implementaci√≥n estricta de "privado" o "protegido" como otros lenguajes (como Java o C++)**. En su lugar, utiliza **convenciones de nomenclatura** para indicar la intenci√≥n de acceso restringido, que se logra mediante el uso de guiones bajos (`_`).

Aqu√≠ te explico c√≥mo se declaran los atributos y m√©todos protegidos y su relaci√≥n con el concepto de acceso restringido.

-----

## üîí 1. Atributos y M√©todos "Protegidos"

El concepto de acceso **"Protegido"** en Python se implementa usando un solo guion bajo al inicio del nombre.

### A. Declaraci√≥n (Convenci√≥n Protegida)

  * **Sintaxis:** Se antepone un solo guion bajo (`_`) al nombre del atributo o m√©todo.
  * **Intenci√≥n:** Indica a otros desarrolladores que este elemento est√° destinado a ser utilizado **solo dentro de la clase** y sus **subclases** (herencia), y **no debe ser accedido o modificado directamente** desde fuera de la clase.

| Tipo | Sintaxis | Ejemplo |
| :--- | :--- | :--- |
| **Atributo Protegido** | `self._nombre_atributo` | `self._saldo = 0` |
| **M√©todo Protegido** | `def _nombre_metodo(self):` | `def _calcular_interes(self):` |

### B. Relaci√≥n con Acceso Restringido

  * **¬øEs forzado? No.** A pesar de la convenci√≥n, Python **permite** acceder y modificar `_saldo` o llamar `_calcular_interes()` desde fuera de la clase.
  * **¬øEntonces para qu√© sirve?** El guion bajo act√∫a como una **advertencia moral y documental**. Es una forma de decir: "Si accedes a esto, lo haces bajo tu propio riesgo; podr√≠a cambiar sin previo aviso en futuras versiones, o podr√≠as romper la l√≥gica interna de la clase".

**Ejemplo de C√≥digo Protegido:**

```python
class CuentaBancaria:
    def __init__(self, saldo_inicial):
        # Atributo "protegido"
        self._saldo = saldo_inicial 
    
    # M√©todo "protegido"
    def _actualizar_registro(self, monto):
        print(f"Registro actualizado: Movimiento de ${monto}")

# Uso (Acceso Externo)
mi_cuenta = CuentaBancaria(100)

# ‚ö†Ô∏è Acceso (permitido, pero desaconsejado)
print(mi_cuenta._saldo)  # 100
mi_cuenta._saldo = 500  # Modificaci√≥n directa (desaconsejada)
mi_cuenta._actualizar_registro(400) # Llamada al m√©todo (desaconsejada)
```

-----

## üö´ 2. El "Truco" para Acceso M√°s Restringido (Privado)

Para crear un nivel de restricci√≥n a√∫n mayor (que se asemeja al concepto de **"Privado"**), Python utiliza una t√©cnica llamada **"Name Mangling"** (manipulaci√≥n de nombres), que se activa con **doble guion bajo** al inicio.

### A. Declaraci√≥n (Convenci√≥n Privada)

  * **Sintaxis:** Se anteponen **dos** guiones bajos (`__`) al nombre del atributo o m√©todo.
  * **Intenci√≥n:** Indica que este elemento es **estrictamente interno** y est√° dise√±ado para evitar colisiones de nombres al heredar de otras clases.

### B. Relaci√≥n con Acceso Restringido (Name Mangling)

  * **¬øEs forzado? S√≠, en cierta medida.** Cuando Python ve `__atributo`, lo renombra internamente a `_NombreClase__atributo` durante la compilaci√≥n.
  * **Resultado:** Esto hace que el acceso directo al nombre original (`mi_objeto.__atributo`) falle, forzando al desarrollador a acceder a trav√©s del nombre manipulado (`mi_objeto._CuentaBancaria__saldo`). Aunque no es una restricci√≥n absoluta, lo hace significativamente m√°s dif√≠cil de acceder por accidente.

**Ejemplo de C√≥digo Privado (Name Mangling):**

```python
class CuentaBancaria:
    def __init__(self, saldo_inicial):
        # Atributo "privado"
        self.__numero_secreto = "12345" 

mi_cuenta = CuentaBancaria(100)

# Acceso fallido:
# print(mi_cuenta.__numero_secreto)  # üö® Arrojar√≠a un error: AttributeError

# Acceso "hackeado" (usando el nombre mangled, desaconsejado):
print(mi_cuenta._CuentaBancaria__numero_secreto) # "12345" (funciona, pero revela la t√©cnica)
```

-----

## üìù Conclusi√≥n

| Concepto Estricto | Convenci√≥n Python | Nomenclatura | Restricci√≥n (Relaci√≥n) |
| :--- | :--- | :--- | :--- |
| **P√∫blico** | P√∫blico por defecto | `nombre_atributo` | Acceso totalmente libre. |
| **Protegido** | **Convenci√≥n** | `_nombre_atributo` (Un guion bajo) | **Advertencia moral**; el acceso est√° permitido pero desaconsejado fuera de la clase y subclases. |
| **Privado** | **Name Mangling** | `__nombre_atributo` (Doble guion bajo) | El acceso directo falla; se requiere un **"hack"** para acceder (es lo m√°s cercano a restringido). |

En resumen, Python se basa en la **confianza y la convenci√≥n** para la restricci√≥n de acceso, priorizando la flexibilidad sobre la rigidez.


Python 3.13.5 (tags/v3.13.5:6cb20a2, Jun 11 2025, 16:15:46) [MSC v.1943 64 bit (AMD64)] on win32
Enter "help" below or click "Help" above for more information.
class Mascota:
    # atributos
    nombre=''
    # m√©todos
    def comer(self):
        return f'{self.nombre} come...'
    def dormir(self):
        return f'{self.nombre} duerme...'
    def darNombre(self, argNombre):
        self.nombre = argNombre
        return f'Tu mascota se llama {self.nombre}'

    

# Crear un objeto
fido = Mascota()
type(fido)
<class '__main__.Mascota'>
fido.darNombre('FIDO')
'Tu mascota se llama FIDO'
fido.comer()
'FIDO come...'
fido.dormir()
'FIDO duerme...'
class Mascota:
    # atributos
    nombre=''
    # m√©todos
    # constructor
    __init__(self, argNombre):
        self.nombre = argNombre
        return f'Tu mascota se llama {self.nombre}'
    def comer(self):
        return f'{self.nombre} come...'
    def dormir(self):
        return f'{self.nombre} duerme...'
    
SyntaxError: invalid syntax
class Mascota:
    # atributos
    nombre=''
    # m√©todos
    # constructor
    def __init__(self, argNombre):
        self.nombre = argNombre
        return f'Tu mascota se llama {self.nombre}'
    def comer(self):
        return f'{self.nombre} come...'
    def dormir(self):
        return f'{self.nombre} duerme...'

    
mascotaDeRicardo = Mascota('LIA')
Traceback (most recent call last):
  File "<pyshell#21>", line 1, in <module>
    mascotaDeRicardo = Mascota('LIA')
TypeError: __init__() should return None, not 'str'
class Mascota:
    # atributos
    nombre=''
    # m√©todos
    # constructor
    def __init__(self, argNombre):
        self.nombre = argNombre
    def comer(self):
        return f'{self.nombre} come...'
    def dormir(self):
        return f'{self.nombre} duerme...'

    
mascotaDeRicardo = Mascota('LIA')
mascotaDeAiron = Mascota('CLOI')
class Mascota:
    # atributos
    nombre=''
    # m√©todos
    # constructor
    def __init__(self, argNombre):
        self.nombre = argNombre
    def comer(self):
        return f'{self.nombre} come...'
    def dormir(self):
        return f'{self.nombre} duerme...'
    def getNombre(self):
        return f'La mascota se llama {self.nombre}'

    
mascotaDeRicardo = Mascota('LIA')
mascotaDeAiron = Mascota('CLOI')
mascotaDeRicardo.comer()
'LIA come...'
mascotaDeAiron.comer()
'CLOI come...'
mascotaDeAiron.getNombre()
'La mascota se llama CLOI'
mascotaDeRicardo.getNombre()
'La mascota se llama LIA'
class Mascota:
    # atributos
    nombre=''
    # m√©todos
    # constructor
    def __init__(self, argNombre):
        self.nombre = argNombre
    def comer(self):
        return f'{self.nombre} come...'
    def dormir(self):
        return f'{self.nombre} duerme...'
    def getNombre(self):
        return f'La mascota se llama {self.nombre}'
    def sonido(self):
        return f'{self.nombre} sonido'

    
#HERENCIA: Todos los atributos y m√©todos de la clase Padre (Superclase)
    
#pasan a las subclases
    

class Canino(Mascota)
SyntaxError: expected ':'
class Canino(Mascota)
SyntaxError: expected ':'
class Canino(Mascota):
    #atributo de la sub clase Canino
    raza = ''
    #m√©todos de la sub clase Canino
    def setRaza(self, argRaza):
        self.raza = argRaza
        return f'La raza asignada a {self.nombre} es {self.raza}'
    def getRaza(self):
        return f'La raza de {self.nombre} es {self.raza}'
    def pasear(self):
        return f'{self.nombre} pasea...'

    
mascotaDeRicardo = Canino('LIA')
mascotaDeRicardo.setRaza('MESTIZA')
'La raza asignada a LIA es MESTIZA'
mascotaDeRicardo.comer()
'LIA come...'
mascotaDeRicardo.dormir()
'LIA duerme...'
mascotaDeRicardo.getRaza()
'La raza de LIA es MESTIZA'
mascotaDeRicardo.pasear()
'LIA pasea...'
mascotaDeRicardo.sonido()
'LIA sonido'
class Canino(Mascota):
    #atributo de la sub clase Canino
    raza = ''
    #m√©todos de la sub clase Canino
    def setRaza(self, argRaza):
        self.raza = argRaza
        return f'La raza asignada a {self.nombre} es {self.raza}'
    def getRaza(self):
        return f'La raza de {self.nombre} es {self.raza}'
    def pasear(self):
        return f'{self.nombre} pasea...'
    def sonido(self)
    
SyntaxError: expected ':'
class Canino(Mascota):
    #atributo de la sub clase Canino
    raza = ''
    #m√©todos de la sub clase Canino
    def setRaza(self, argRaza):
        self.raza = argRaza
        return f'La raza asignada a {self.nombre} es {self.raza}'
    def getRaza(self):
        return f'La raza de {self.nombre} es {self.raza}'
    def pasear(self):
        return f'{self.nombre} pasea...'
    def sonido(self):
        return f'{self.nombre} ladra...'

    
class Felino(Mascota):
    #atributo de la sub clase Felino
    raza = ''
    #m√©todos de la sub clase Canino
    def setRaza(self, argRaza):
        self.raza = argRaza
        return f'La raza asignada a {self.nombre} es {self.raza}'
    def getRaza(self):
        return f'La raza de {self.nombre} es {self.raza}'
    def pasear(self):
        return f'{self.nombre} pasea...'
    def sonido(self):
        return f'{self.nombre} maulla...'

    
class Felino(Mascota):
    #atributo de la sub clase Felino
    raza = ''
    #m√©todos de la sub clase Felino
    def setRaza(self, argRaza):
        self.raza = argRaza
        return f'La raza asignada a {self.nombre} es {self.raza}'
    def getRaza(self):
        return f'La raza de {self.nombre} es {self.raza}'
    def pasear(self):
        return f'{self.nombre} pasea...'
    def sonido(self):
        return f'{self.nombre} maulla...'

    
class Pez(Mascota):
    #atributo de la sub clase Pez
    raza = ''
    #m√©todos de la sub clase Pez
    def setRaza(self, argRaza):
        self.raza = argRaza
        return f'La raza asignada a {self.nombre} es {self.raza}'
    def getRaza(self):
        return f'La raza de {self.nombre} es {self.raza}'
    def pasear(self):
        return f'{self.nombre} pasea...'
    def sonido(self):
        return f'{self.nombre} no emite sonido...'

    
mascotaDeRicardo = Canino('LIA')
mascotaDeAiron = Pez('CLOI')
mascotaDeAaron = Felino('FLOFLY')
mascotaDeRicardo.sonido()
'LIA ladra...'
mascotaDeAiron.sonido()
'CLOI no emite sonido...'
mascotaDeAaron.sonido()
'FLOFLY maulla...'
#ENCAPSULAMIENTO
class CuentaBancaria:
    #atributos publicos
    tipoCuenta = ''
    fechaCreacion = ''
    #atributos privados
    _saldo = 0
    _titular = ''
    #M√©todos
    #Constructor
    def __init__ abrirCuenta(self,argTipoCta,argCrea,argDepo,argTit):
        
SyntaxError: expected '('
class CuentaBancaria:
    #atributos publicos
    tipoCuenta = ''
    fechaCreacion = ''
    #atributos privados
    _saldo = 0
    _titular = ''
    #M√©todos
    #Constructor
    def __init__(self,argTipoCta,argCrea,argDepo,argTit):
        self.tipoCuenta = argTipoCta
        self.fechaCreacion = argCrea
        self._saldo = argDepo
        self._titular = argTit


miCuenta = CuentaBancaria('AHO','2025-12-13',100,'HENRY')
miCuenta.fechaCreacion
'2025-12-13'
miCuenta.tipoCuenta
'AHO'
class CuentaBancaria:
    #atributos publicos
    tipoCuenta = ''
    fechaCreacion = ''
    #atributos privados
    _saldo = 0
    _titular = ''
    #M√©todos
    #Constructor
    def __init__(self,argTipoCta,argCrea,argDepo,argTit):
        self.tipoCuenta = argTipoCta
        self.fechaCreacion = argCrea
        self._saldo = argDepo
        self._titular = argTit
    def setDeposito(self,argDepo):
        self._saldo += argDepo
    def getSaldo(self):
        return f'El saldo de la cuenta es {self.saldo}'
    def setTitular(self,argTit):
        self._titular = argTit
    def getTitular(self):
        return f'El nombre del titular de la cuenta es {self.nombre}'

    
miCuenta = CuentaBancaria('AHO','2025-12-13',100,'HENRY')
miCuenta.fechaCreacion
'2025-12-13'
}
miCuenta.tipoCuenta
'AHO'
miCuenta.getTitular()
Traceback (most recent call last):
  File "<pyshell#117>", line 1, in <module>
    miCuenta.getTitular()
  File "<pyshell#113>", line 22, in getTitular
    return f'El nombre del titular de la cuenta es {self.nombre}'
AttributeError: 'CuentaBancaria' object has no attribute 'nombre'
class CuentaBancaria:
    #atributos publicos
    tipoCuenta = ''
    fechaCreacion = ''
    #atributos privados
    _saldo = 0
    _titular = ''
    #M√©todos
    #Constructor
    def __init__(self,argTipoCta,argCrea,argDepo,argTit):
        self.tipoCuenta = argTipoCta
        self.fechaCreacion = argCrea
        self._saldo = argDepo
        self._titular = argTit
    def setDeposito(self,argDepo):
        self._saldo += argDepo
    def getSaldo(self):
        return f'El saldo de la cuenta es {self._saldo}'
    def setTitular(self,argTit):
        self._titular = argTit
    def getTitular(self):
        return f'El nombre del titular de la cuenta es {self._titular}'

    
miCuenta = CuentaBancaria('AHO','2025-12-13',100,'HENRY')
miCuenta.getTitular()
'El nombre del titular de la cuenta es HENRY'
miCuenta.getSaldo()
'El saldo de la cuenta es 100'
miCuenta.setDeposito(255)
miCuenta.getSaldo()
'El saldo de la cuenta es 355'
miCuenta.setTitular('HENRY DUQUE')
miCuenta.getTitular()
'El nombre del titular de la cuenta es HENRY DUQUE'


INSTALACI√ìN DE DEPENDENCIA PARA POSTGRESQL EN EL Entorno
VIRTUAL PARA PYTHON.
pip install psycopg2 


Python 3.13.5 (tags/v3.13.5:6cb20a2, Jun 11 2025, 16:15:46) [MSC v.1943 64 bit (AMD64)] on win32
Enter "help" below or click "Help" above for more information.
import psycopg2
conn = psycopg2.connect("database=bd20251025_profesor user=postgres password=123456 host=localhost port=5432")
Traceback (most recent call last):
  File "<pyshell#1>", line 1, in <module>
    conn = psycopg2.connect("database=bd20251025_profesor user=postgres password=123456 host=localhost port=5432")
  File "C:\Users\INSTRUCTOR\AppData\Roaming\Python\Python313\site-packages\psycopg2\__init__.py", line 134, in connect
    dsn = _ext.make_dsn(dsn, **kwargs)
  File "C:\Users\INSTRUCTOR\AppData\Roaming\Python\Python313\site-packages\psycopg2\extensions.py", line 145, in make_dsn
    parse_dsn(dsn)
psycopg2.ProgrammingError: invalid dsn: invalid connection option "database"

conn = psycopg2.connect(database="bd20251025_profesor",user="postgres",password="123456", host="localhost", port="5432")
cursor = conn.cursor()
sql = "select * from proveedores"
cursor.execute(sql)
resultado = cursor.fetchall()
for data in resultado:
    data

    
(2, 'WHIRPOOL', 'AV. BARALT', '+58 212 4876543', 'info@whirpool.com')
(3, 'SAMSUNG', 'AV. SAN MARTIN', '+58 212 7876543', 'info@samsung.com')
(4, 'ADMIRAL', 'AV. ROMULO GALLEGOS', '+58 212 2876543', 'info@admiral.com')


